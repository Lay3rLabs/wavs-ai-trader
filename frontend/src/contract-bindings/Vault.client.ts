/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * This file was automatically generated by @cosmwasm/ts-codegen@1.13.3.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { ICosmWasmClient, ISigningCosmWasmClient } from "./baseClient";
import { StdFee } from "@interchainjs/types";
import {
  Uint256,
  Decimal256,
  Action,
  WavsEnvelope,
  PriceInfo,
  SwapRoute,
  WavsSignatureData,
  Addr,
  DepositRequest,
  Coin,
  ArrayOfCoin,
  ArrayOfPriceInfo,
  VaultState,
  ArrayOfString,
  ArrayOfDepositRequest,
  OwnershipForString,
} from "./Vault.types";
export interface VaultReadOnlyInterface {
  contractAddress: string;
  getTotalShares: () => Promise<Uint256>;
  getVaultValue: () => Promise<Decimal256>;
  getWhitelistedDenoms: () => Promise<ArrayOfString>;
  getDepositRequest: ({
    depositId,
  }: {
    depositId: number;
  }) => Promise<DepositRequest>;
  listDepositRequests: ({
    limit,
    startAfter,
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<ArrayOfDepositRequest>;
  getVaultAssets: () => Promise<ArrayOfCoin>;
  getVaultAssetBalance: ({ denom }: { denom: string }) => Promise<Uint256>;
  getPendingAssets: () => Promise<ArrayOfCoin>;
  getPendingAssetBalance: ({ denom }: { denom: string }) => Promise<Uint256>;
  getPrice: ({ denom }: { denom: string }) => Promise<Decimal256>;
  getPrices: () => Promise<ArrayOfPriceInfo>;
  getVaultState: () => Promise<VaultState>;
  ownership: () => Promise<OwnershipForString>;
  wavsServiceManager: () => Promise<Addr>;
}
export class VaultQueryClient implements VaultReadOnlyInterface {
  client: ICosmWasmClient;
  contractAddress: string;
  constructor(client: ICosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getTotalShares = this.getTotalShares.bind(this);
    this.getVaultValue = this.getVaultValue.bind(this);
    this.getWhitelistedDenoms = this.getWhitelistedDenoms.bind(this);
    this.getDepositRequest = this.getDepositRequest.bind(this);
    this.listDepositRequests = this.listDepositRequests.bind(this);
    this.getVaultAssets = this.getVaultAssets.bind(this);
    this.getVaultAssetBalance = this.getVaultAssetBalance.bind(this);
    this.getPendingAssets = this.getPendingAssets.bind(this);
    this.getPendingAssetBalance = this.getPendingAssetBalance.bind(this);
    this.getPrice = this.getPrice.bind(this);
    this.getPrices = this.getPrices.bind(this);
    this.getVaultState = this.getVaultState.bind(this);
    this.ownership = this.ownership.bind(this);
    this.wavsServiceManager = this.wavsServiceManager.bind(this);
  }
  getTotalShares = async (): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_total_shares: {},
    });
  };
  getVaultValue = async (): Promise<Decimal256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_vault_value: {},
    });
  };
  getWhitelistedDenoms = async (): Promise<ArrayOfString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_whitelisted_denoms: {},
    });
  };
  getDepositRequest = async ({
    depositId,
  }: {
    depositId: number;
  }): Promise<DepositRequest> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_deposit_request: {
        deposit_id: depositId,
      },
    });
  };
  listDepositRequests = async ({
    limit,
    startAfter,
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<ArrayOfDepositRequest> => {
    return this.client.queryContractSmart(this.contractAddress, {
      list_deposit_requests: {
        limit,
        start_after: startAfter,
      },
    });
  };
  getVaultAssets = async (): Promise<ArrayOfCoin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_vault_assets: {},
    });
  };
  getVaultAssetBalance = async ({
    denom,
  }: {
    denom: string;
  }): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_vault_asset_balance: {
        denom,
      },
    });
  };
  getPendingAssets = async (): Promise<ArrayOfCoin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_assets: {},
    });
  };
  getPendingAssetBalance = async ({
    denom,
  }: {
    denom: string;
  }): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_asset_balance: {
        denom,
      },
    });
  };
  getPrice = async ({ denom }: { denom: string }): Promise<Decimal256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_price: {
        denom,
      },
    });
  };
  getPrices = async (): Promise<ArrayOfPriceInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_prices: {},
    });
  };
  getVaultState = async (): Promise<VaultState> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_vault_state: {},
    });
  };
  ownership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ownership: {},
    });
  };
  wavsServiceManager = async (): Promise<Addr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      wavs_service_manager: {},
    });
  };
}
export interface VaultInterface extends VaultReadOnlyInterface {
  contractAddress: string;
  sender: string;
  deposit: (
    fee_?: number | StdFee | "auto",
    memo_?: string,
    funds_?: Coin[]
  ) => Promise<any>;
  withdraw: (
    {
      shares,
    }: {
      shares: Uint256;
    },
    fee_?: number | StdFee | "auto",
    memo_?: string,
    funds_?: Coin[]
  ) => Promise<any>;
  updateWhitelist: (
    {
      toAdd,
      toRemove,
    }: {
      toAdd?: string[];
      toRemove?: string[];
    },
    fee_?: number | StdFee | "auto",
    memo_?: string,
    funds_?: Coin[]
  ) => Promise<any>;
  updatePrices: (
    {
      prices,
      swapRoutes,
    }: {
      prices: PriceInfo[];
      swapRoutes?: SwapRoute[];
    },
    fee_?: number | StdFee | "auto",
    memo_?: string,
    funds_?: Coin[]
  ) => Promise<any>;
  updateOwnership: (
    action: Action,
    fee_?: number | StdFee | "auto",
    memo_?: string,
    funds_?: Coin[]
  ) => Promise<any>;
  wavsHandleSignedEnvelope: (
    {
      envelope,
      signatureData,
    }: {
      envelope: WavsEnvelope;
      signatureData: WavsSignatureData;
    },
    fee_?: number | StdFee | "auto",
    memo_?: string,
    funds_?: Coin[]
  ) => Promise<any>;
}
export class VaultClient extends VaultQueryClient implements VaultInterface {
  client: ISigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(
    client: ISigningCosmWasmClient,
    sender: string,
    contractAddress: string
  ) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.deposit = this.deposit.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.updateWhitelist = this.updateWhitelist.bind(this);
    this.updatePrices = this.updatePrices.bind(this);
    this.updateOwnership = this.updateOwnership.bind(this);
    this.wavsHandleSignedEnvelope = this.wavsHandleSignedEnvelope.bind(this);
  }
  deposit = async (
    fee_: number | StdFee | "auto" = "auto",
    memo_?: string,
    funds_?: Coin[]
  ): Promise<any> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        deposit: {},
      },
      fee_,
      memo_,
      funds_
    );
  };
  withdraw = async (
    {
      shares,
    }: {
      shares: Uint256;
    },
    fee_: number | StdFee | "auto" = "auto",
    memo_?: string,
    funds_?: Coin[]
  ): Promise<any> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        withdraw: {
          shares,
        },
      },
      fee_,
      memo_,
      funds_
    );
  };
  updateWhitelist = async (
    {
      toAdd,
      toRemove,
    }: {
      toAdd?: string[];
      toRemove?: string[];
    },
    fee_: number | StdFee | "auto" = "auto",
    memo_?: string,
    funds_?: Coin[]
  ): Promise<any> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_whitelist: {
          to_add: toAdd,
          to_remove: toRemove,
        },
      },
      fee_,
      memo_,
      funds_
    );
  };
  updatePrices = async (
    {
      prices,
      swapRoutes,
    }: {
      prices: PriceInfo[];
      swapRoutes?: SwapRoute[];
    },
    fee_: number | StdFee | "auto" = "auto",
    memo_?: string,
    funds_?: Coin[]
  ): Promise<any> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_prices: {
          prices,
          swap_routes: swapRoutes,
        },
      },
      fee_,
      memo_,
      funds_
    );
  };
  updateOwnership = async (
    action: Action,
    fee_: number | StdFee | "auto" = "auto",
    memo_?: string,
    funds_?: Coin[]
  ): Promise<any> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_ownership: action,
      },
      fee_,
      memo_,
      funds_
    );
  };
  wavsHandleSignedEnvelope = async (
    {
      envelope,
      signatureData,
    }: {
      envelope: WavsEnvelope;
      signatureData: WavsSignatureData;
    },
    fee_: number | StdFee | "auto" = "auto",
    memo_?: string,
    funds_?: Coin[]
  ): Promise<any> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        wavs_handle_signed_envelope: {
          envelope,
          signature_data: signatureData,
        },
      },
      fee_,
      memo_,
      funds_
    );
  };
}
